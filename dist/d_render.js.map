{
  "version": 3,
  "sources": ["../src/util.js", "../src/hook_helpers.js", "../src/hooks.js", "../src/component.js", "../src/d_render.js"],
  "sourcesContent": ["let turboCompatible = true\n\nconst debug = {\n  logAllFuncStr: false,\n  keepDirectives: turboCompatible,\n  logCompiledFuncExecutionError: true,\n}\n\nconst addReturnToScriptStr = (str) => {\n  let arr = str.split(';')\n  let last = arr[arr.length - 1]\n  arr[arr.length - 1] = `return ${last}`\n  return arr.join(\";\\n\")\n}\n\nconst unsafeEvalSupported = (() => {\n  let unsafeEval = true\n  try\n  {\n    const func = new Function('param1', 'param2', 'param3', 'return param1[param2] === param3;');\n    unsafeEval = func({ a: 'b' }, 'a', 'b') === true;\n  }\n  catch (e)\n  {\n    unsafeEval = false;\n  }\n  return unsafeEval\n})()\n\nconst fallbackCompileToFunc = (codeStr) => {\n  var result;\n\n  // Define callback\n  window.evalCallback = (r) => result = r\n\n  var newScript = document.createElement(\"script\");\n  var nonce = document.querySelector(\"meta[name=csp-nonce]\").content\n  newScript.setAttribute('nonce', nonce);\n  newScript.innerHTML = \"evalCallback(\" + codeStr + \");\";\n  document.body.appendChild(newScript);\n\n  // Now clean up DOM and global scope\n  document.body.removeChild(newScript);\n  delete window.evalCallback;\n  return result;\n};\n\n// Compile string to function\n// the last arguments is the string, rest of them would be arguments of the compiled function\nconst compileToFunc = (...args) => {\n  let options = typeof args[args.length - 1] == 'object' ? args.pop() : {}\n  let { addReturn = false } = options\n\n  if (addReturn) {\n    args[args.length - 1] = addReturnToScriptStr(args[args.length - 1])\n  }\n\n  if (debug.logCompiledFuncExecutionError) {\n    let str = args[args.length - 1]\n    let logStr = str.replaceAll('\"', `\\\\\\\"`).replaceAll(\"\\n\", \"\\\\n\")\n    str = `\n      try {\n        ${str}\n      } catch (e) {\n        console.log(\"Error occurred when executing compiled function:\")\n        console.log(\"${logStr}\")\n        throw e\n      }\n    `\n    args[args.length - 1] = str\n  }\n\n  try {\n    if (unsafeEvalSupported) {\n      debug.logAllFuncStr && console.log(\"Compile string to function via 'new Function()':\\n\", `new Function(${args.map(e => `\"${e}\"`).join(\", \")})`)\n      return (new Function(...args))\n    } else {\n      let body = args.pop()\n      let str = `function(${args.join(\", \")}) { ${body} }`\n      debug.logAllFuncStr && console.log(\"Compile string to function via <script>:\\n\", str)\n      return fallbackCompileToFunc(str)\n    }\n  } catch (e) {\n    console.log(\"Error occurred when compiling function from string:\")\n    console.log(args[args.length - 1])\n    throw e\n  }\n}\n\nconst getDescriptor = (obj, method) => {\n  let prototype = Object.getPrototypeOf(obj)\n  let descriptor = undefined\n\n  while(true) {\n    descriptor = Object.getOwnPropertyDescriptor(prototype, method)\n\n    if (descriptor != undefined || prototype == Object.prototype) {\n      break\n    } else {\n      prototype = Object.getPrototypeOf(prototype)\n    }\n  }\n  return descriptor\n}\n\n// Compile str with the `with` syntax to function and bind to the component.\n// If the last of args is a function, it will be invoked to transform the str before compiling.\n// Convention:\n//  If the str is a method name of component, the matching method of component would be returned regardless of other args.\nconst compileWithComponent = (str, component, ...args) => {\n  let func\n  let descriptor = getDescriptor(component, str)\n\n  if (descriptor && !descriptor.get && typeof component[str] == 'function') {\n    func = component[str].bind(component)\n  } else {\n    let transformStrFunc = args[args.length - 1]\n    if (typeof transformStrFunc == 'function') {\n      args.pop()\n      str = transformStrFunc(str)\n    } else {\n      str = addReturnToScriptStr(str)\n    }\n    str = `\n        with(this) {\n          with(context) {\n            with (state) {\n              ${str}\n            }\n          }\n        }\n      `\n    func = compileToFunc(...args, str).bind(component)\n  }\n  return func\n}\n\nconst deepMerge = (obj, ...sources) => {\n  for (let source of sources) {\n    for (let key in source) {\n      let value = obj[key], newValue = source[key]\n      if (value && value.constructor == Object && newValue && newValue.constructor == Object) {\n        obj[key] = deepMerge(value, newValue)\n      } else {\n        obj[key] = newValue\n      }\n    }\n  }\n  return obj\n}\n\nconst getAttribute = (node, name) => node.getAttribute(name)\nconst setAttribute = (node, name, value) => node.setAttribute(name, value)\nconst removeAttribute = (node, name) => node.removeAttribute(name)\nconst getData = (node, name) => {\n  try {\n    return JSON.parse(node.dataset[name])\n  } catch (e) {\n    return node.dataset[name]\n  }\n}\nconst setData = (node, name, value) => node.dataset[name] = (typeof value == 'object' ? JSON.stringify(value) : value)\nconst emitEnvent = (node, event) => node.dispatchEvent(new Event(event))\nconst findInside = (node, selector) => [...$(node).find(selector)]\nconst querySelectorAll = selector => [...document.querySelectorAll(selector)]\n\nconst parents = (node, selector) => $(node).parents(select).toArray()\nconst isTag = (node, selector) => $(node).is(selector)\n\nconst isNil = (obj) => obj === undefined || obj === null\n\nexport {\n  debug,\n  addReturnToScriptStr,\n  unsafeEvalSupported,\n  fallbackCompileToFunc,\n  compileToFunc,\n  compileWithComponent,\n  deepMerge,\n  getAttribute,\n  setAttribute,\n  removeAttribute,\n  getData,\n  setData,\n  emitEnvent,\n  findInside,\n  querySelectorAll,\n  parents,\n  isTag,\n  isNil,\n}\n", "import { debug, getAttribute, removeAttribute, setAttribute, compileWithComponent } from './util'\n\n//Split and Collect Prefixes from the str\n//e.g:\n//  given the string below\n//    \".prevent.stop { updating: true }\n//returns [\"{ updating: true }\", [\".prevent\", \".stop\"]]\nconst collectPrefixes = (str) => {\n  let prefixes = str.match(/^\\.[^\\s]+\\s/)\n  if (prefixes) {\n    prefixes = prefixes[0].substring(1).split('.').map(prefix => `.${prefix}`.trim() )\n    str = str.replace(/^\\.[^\\s]+\\s/, '')\n  }\n  return [str, prefixes]\n}\n\n// This function returns a function that stored in Hooks and invoked in Component#registerHooks()\n// When the returned function gets invoked:\n//  It compiles the directive value to a handler function. And then registers the handler to event listener.\n//  Convention:\n//    If the directive value starts with \"{\", transform to \"this.setState(${originalStr})\" before compiling.\n//    If preDefinedStr is present, use it to compile the handle function.\nconst generateEventFunc = (identifier, event, preDefinedStr = null) => {\n  return (component, node) => {\n    let originalStr = preDefinedStr ? preDefinedStr.trim() : getAttribute(node, identifier).trim()\n    let [str, prefixes] = collectPrefixes(originalStr)\n\n    let handler = compileWithComponent(str, component, 'event', (str) => str[0] == '{' ? `this.setState(${str})` : str)\n    prefixes && prefixes.forEach((prefix) => {\n      handler = Prefixes[prefix] ? Prefixes[prefix](handler, component, node, prefixes) : handler\n    })\n\n    component.addEventListener(event, node, handler)\n    !debug.keepDirectives && removeAttribute(node, identifier)\n  }\n}\n\n// This function returns a function that invoked in generateDirectiveFunc\n// Similar with Redux#compose, When the returned function gets invoked:\n//  It returns another function with handler function as argument to be able to chaining.\nconst generatePrefixFunc = (func) => {\n  return (handler, component, node, prefixes) => {\n    return (event) => {\n      func(handler, event, component, node, prefixes)\n    }\n  }\n}\n\n// This function returns a function that stored in Hooks\n// When the returned function gets invoked:\n//  It compiles the directive value to a result function.\n//  It pushes a hook object with the callback function to Component#renderHooks\n//  When the hook gets invoked, the callback function updates DOM accordingly based on the return value of the result function.\nconst generateDirectiveFunc = (identifier, prop, callbackFunc) => {\n  return (component, node) => {\n    let originalProp = prop ? getAttribute(node, prop) : null\n    let str = getAttribute(node, identifier).trim()\n    let resultFunc = compileWithComponent(str, component, 'node', 'transition')\n\n    !debug.keepDirectives && removeAttribute(node, identifier)\n    component.renderHooks.push({\n      identifier,\n      value: str,\n      node,\n      hook: (transition) => callbackFunc(node, resultFunc(node, transition), component, originalProp)\n    })\n  }\n}\n\n// Prefixes: a constant object to hold the prefix functions. Form: { [prefix string]: prefix function }.\n// The prefix function gets executed when the prefix string matched in generateEventFunc.\n//  It takes four arguments: handler, component, node, prefixes, and returns a function which gets invoked in the event listener.\n//  handler: the chaining handler function, called to run other handlers.\n//\n// e.g: register a 'esc' prefix to handle esc pressing.\n//   Prefixes['.esc'] = (handler, component, node, prefixes) => {\n//     return (event) => {\n//       if (event.type == 'keyup' && event.key == 'esc') {\n//          event.preventDefault()\n//          // do something special for esc pressing, like compiling the directive value to function and run it\n//       } else {\n//         handler() //not pressing esc, do nothing and pass to the next handler.\n//       }\n//     }\n//   }\nconst Prefixes = {\n  '.prevent': generatePrefixFunc((handler, event, _component, _node, _prefixes) => {\n    event.preventDefault()\n    handler(event)\n  }),\n  '.stop': generatePrefixFunc((handler, event, _component, _node, _prefixes) => {\n    event.stopPropagation()\n    handler(event)\n  }),\n  '.debounce': generatePrefixFunc((handler, event, _component, node, _prefixes) => {\n    let time = getAttribute(node, 'd-debounce-duration') || 400\n    let timer = parseInt(getData(node, `drender-${event.type}-debounce`))\n    timer && clearTimeout(timer)\n    timer = setTimeout(() => handler(event), time)\n    setData(node, `drender-${event.type}-debounce`, timer)\n  }),\n}\n\nexport {\n  collectPrefixes,\n  generateEventFunc,\n  generatePrefixFunc,\n  generateDirectiveFunc,\n  Prefixes,\n}\n\n", "// Hooks: a constant object to hold the hook functions. Form: { [directive string]: hook function }.\n//  The hook function gets executed in Component#registerHooks.\n//  Each of them registers a hook object either to the renderHooks which invoked in Component#render,\n//  or to the stateHooks which invoked in Component#setState\n//  The hook function takes two arguments: component, $node.\n//\n//  e.g: add a d-debug directive to log the state\n//    Hooks['d-debug'] = (component, $node) => {\n//    component.stateHooks.push({\n//      identifier: 'd-log',\n//      value: null,\n//      $node,\n//      hook: () => console.log(component.state)\n//    })\n//  }\n\nimport { collectPrefixes, generateEventFunc, generatePrefixFunc, generateDirectiveFunc, Prefixes } from './hook_helpers'\nimport { debug, isTag, deepMerge, compileWithComponent, getAttribute, setAttribute, getData, setData } from './util'\n\nconst Hooks = {\n  'd-model': (component, node) => {\n    let key = getAttribute(node, 'd-model')\n    let a = generateEventFunc('d-model', 'input', `{ ${key}: event.target.value }`)\n    a(component, node)\n    component.renderHooks.push({\n      identifier: 'd-model',\n      value: key,\n      node,\n      hook: () => node.value = component.state[key]\n    })\n  },\n  'd-loop': (component, node) => {\n    if (node.children.length != 1) {\n      throw new Error(\"Must only have one root element inside the d-loop.\")\n    }\n\n    let keyStr = getAttribute(node.children[0], 'd-key'),\n      loopStr = getAttribute(node, 'd-loop'),\n      varStr = getAttribute(node, 'd-loop-var') || 'loopItem',\n      loopItemKey = `${varStr}Key`, loopItem = varStr, loopItemIndex = `${varStr}Index`\n\n    // The first child is always a d-component\n    !getAttribute(node.children[0], 'd-component') && setAttribute(node.children[0], 'd-component', '')\n\n    if (keyStr == undefined) {\n      throw new Error(\"The root element inside d-loop must have d-key directive\")\n    }\n\n    const loopFunc = compileWithComponent(loopStr, component)\n    const keyFunc = compileWithComponent(keyStr, component, loopItemKey, loopItem, loopItemIndex)\n\n    const iterate = (items, func) => {\n      if (items.constructor == Array) {\n        items.forEach((value, index) => func({ [loopItemKey]: null, [loopItem]: value, [loopItemIndex]: index }))\n      } else {\n        Object.entries(items).forEach(([key, value], index) => func({ [loopItemKey]: key, [loopItem]: value, [loopItemIndex]: index }))\n      }\n    }\n\n    orginalNode = node.children[0].cloneNode(true)\n    node.innerHTML = ''\n\n    const append = (childComponentKey, context) => {\n      let childNode = orginalNode.cloneNode(true)\n      childNode.context = { ...context, _loopComponentKey: childComponentKey }\n      node.appendChild(childNode)\n      return createComponent(childNode)\n    }\n\n    iterate(loopFunc(component), (context) => {\n      let childComponentKey = keyFunc(...Object.values(context))\n      append(childComponentKey, context)\n    })\n\n    if (!debug.keepDirectives) {\n      removeAttribute(node, 'd-loop d-loop-var')\n      for (const child of node.children) { removeAttribute(child, 'd-key') }\n    }\n\n    const loopHook = () => {\n      let results = loopFunc(component)\n      let updated = {}\n\n      let children = [...node.children].reduce((map, child) => {\n        let component = child._dComponent\n        map[component.context._loopComponentKey] = component\n        return map\n      }, {})\n\n      iterate(results, (context) => {\n        let childComponentKey = keyFunc(...Object.values(context))\n        let childComponent = children[childComponentKey]\n\n        if (childComponent) {\n          childComponent.context = deepMerge({}, childComponent.context, context)\n        } else {\n          childComponent = append(childComponentKey, context)\n        }\n        $node.appendChild(childComponent.element)\n        updated[childComponentKey] = true\n      })\n\n      Object.entries(children).forEach(([k, childComponent]) => {\n        (updated[k] == undefined) && childComponent.element.remove()\n      })\n    }\n\n    component.stateHooks.push({\n      identifier: 'd-loop',\n      value: loopStr,\n      node,\n      hook: loopHook\n    })\n  },\n  'd-keyup': generateEventFunc('d-keyup', 'keyup'),\n  'd-keypress': generateEventFunc('d-keypress', 'keypress'),\n  'd-change': generateEventFunc('d-change', 'change'),\n  'd-input': generateEventFunc('d-input', 'input'),\n  'd-click': generateEventFunc('d-click', 'click'),\n  'd-submit': generateEventFunc('d-submit', 'submit'),\n  'd-focus': generateEventFunc('d-focus', 'focus'),\n  'd-blur': generateEventFunc('d-blur', 'blur'),\n  'd-show': generateDirectiveFunc('d-show', null, (node, result, _component) => {\n    node.classList.toggle('hidden', !(!!result))\n  }),\n  'd-debounce-show': generateDirectiveFunc('d-debounce-show', null, (node, result, _component) => {\n    let timer = parseInt(getData(node, 'drender-debounce-show'))\n    if (!!result == true) {\n      let time = getAttribute(node, 'd-debounce-duration') || 400\n      timer && clearTimeout(timer);\n      timer = setTimeout(() => node.classList.toggle('hidden', !(!!result)), time);\n      setData(node, `drender-debounce-show`, timer)\n    } else {\n      node.classList.toggle('hidden', !(!!result))\n      timer && clearTimeout(timer);\n    }\n  }),\n  'd-class': generateDirectiveFunc('d-class', 'class', (node, result, _component, originalClassName) => {\n    if (typeof result == 'object') {\n      Object.entries(result).forEach(([name, state]) => node.classList.toggle(name, state))\n    } else {\n      node.className = `${originalClassName || ''} ${result}`\n    }\n  }),\n  'd-debounce-class': generateDirectiveFunc('d-debounce-class', null, (node, result, _component) => {\n    let timerHash = getData(node, `drender-debounce-class`) || {}\n    Object.entries(result).forEach(([name, state]) => {\n      let timer = timerHash[name]\n      if (state) {\n        let time = node.getAttribute('d-debounce-duration') || 400\n        timer && clearTimeout(timer);\n        timer = setTimeout(() => { node.classList.add(name) }, time)\n        timerHash[name] = timer\n      } else {\n        node.classList.remove(name)\n        timer && clearTimeout(timer);\n      }\n    })\n    setData(node, 'drender-debounce-class', timerHash)\n  }),\n  'd-style': generateDirectiveFunc('d-style', null, (node, result, _component) => {\n    Object.entries(result).forEach(([name, state]) => node.style[name] = state)\n  }),\n  'd-disabled': generateDirectiveFunc('d-disabled', null, (node, result, _component) => {\n    node.disabled = !!result\n  }),\n  'd-readonly': generateDirectiveFunc('d-readonly', 'readonly', (node, result, _component, _originalProp) => {\n    node.readOnly = !!result\n  }),\n  'd-text': generateDirectiveFunc('d-text', null, (node, result, _component, _originalProp) => {\n    isTag(node, 'input, textarea') ? (node.value = result) : (node.innerText = result)\n  }),\n  'd-html': generateDirectiveFunc('d-html', null, (node, result, _component, _originalProp) => {\n    isTag(node, 'input, textarea') ? (node.value = result) : (node.innerHTML = result)\n  }),\n  'd-prop': generateDirectiveFunc('d-prop', null, (node, result, _component, _originalProp) => {\n    Object.entries(result).forEach(([name, state]) => node[name] = state)\n  }),\n  'd-on-state-change': (component, node) => {\n    let str = getAttribute(node, 'd-on-state-change')\n    let func = compileWithComponent(str, component, 'node', 'prevState')\n    component.stateHooks.push({\n      identifier: 'd-on-state-change',\n      value: str,\n      node,\n      hook: (prevState) => func(node, prevState)\n    })\n    !debug.keepDirectives && removeAttribute(node, 'd-on-state-change')\n  },\n  'd-on-render': (component, node) => {\n    let str = getAttribute(node, 'd-on-render')\n    let func = compileWithComponent(str, component, 'node', 'transition')\n    component.renderHooks.push({\n      identifier: 'd-on-render',\n      value: str,\n      node,\n      hook: (transition) => func(node, transition)\n    })\n    !debug.keepDirectives && removeAttribute(node, 'd-on-render')\n  },\n}\n\nexport { Hooks }\n", "import { debug, getAttribute, setAttribute, removeAttribute, deepMerge, findInside, isTag, parents, getData, compileToFunc, compileWithComponent } from './util'\nimport { Hooks } from './hooks'\n\nclass Component {\n  constructor(element) {\n    this.element = element\n    this.renderHooks = []\n    this.stateHooks = []\n    this.refs = {}\n    this.eventsMap = {}\n\n    let state = {}, str = getAttribute(element, 'd-state')\n    // use return directly in case the values of state hash has ; inside\n    if (str) {\n      str = `\n        with(this) {\n          with(context) {\n            return ${str}\n          }\n        }\n      `\n      state = compileToFunc('context = {}', str).bind(this)(this.context)\n    }\n\n    this.state = deepMerge({}, state)\n    this.initialState = deepMerge({}, this.state)\n\n    this.registerHooks()\n    this.registerRefs()\n  }\n\n  addEventListener(eventIdentifier, node, handler) {\n    !this.eventsMap[node] && (this.eventsMap[node] = {})\n    this.eventsMap[node][eventIdentifier] = handler\n    node.addEventListener(eventIdentifier, handler)\n  }\n\n  removeEventListener(eventIdentifier, node) {\n    let handler = this.eventsMap[node][eventIdentifier]\n    node.removeEventListener(eventIdentifier, handler)\n  }\n\n  // A lifecycle hook to run d-after-initialized directive.\n  // also it's for something after component initialized like caching the parent/children\n  // e.g: cache the parent and children after initializing, so that each time calling parent/children won't do the search on the DOM tree.\n  // this.parent = this.parent\n  // this.children = this.children\n  afterInitialized() {\n    let hook = 'd-after-initialized'\n    const func = (node) => {\n      let str = getAttribute(node, hook).trim()\n      let resultFunc = compileWithComponent(str, this, 'node')\n      resultFunc(node)\n    }\n    this.findTopLevel(`[${hook}]`).forEach(func)\n    getAttribute(this.element, hook) && func(this.element)\n  }\n\n  // The key of context object could be direclty used in html directive.\n  // e.g:\n  //  given context: { outsideComponentData: 1 }\n  //  in html directive, 'd-show': '{ data: outsideComponentData + 1 }'\n  //\n  // Note that\n  // If you want modify the data('d-component-context'), always use $.extend to clone first\n  // Because it's used for d-loop internally.\n  // e.g:\n  //   let old = this.element.dComponentContext\n  //   let new = { ...old, ...updated }\n  //   this.element.dComponentContext = new\n  get context() {\n    return this.element._dComponentContext || {}\n  }\n\n  set context(context) {\n    return this.element._dComponentContext = context\n  }\n\n  set parent(parent) {\n    this._parent = parent\n  }\n\n  get parent() {\n    return this._parent || parents(this.element, '[d-component], [d-state]')[0]._dComponent\n  }\n\n  set children(children) {\n    this._children = children\n  }\n\n  get children() {\n    if (this._children) {\n      return [...this._children] //always return a new array in case someone modify the array using things like Array.prototype.reverse\n    } else {\n      return this.findChildrenElements({ includeElementInLoop: true }).map(e => e._dComponent)\n    }\n  }\n\n  // find the most upper children that matches [d-component] or [d-state]\n  findChildrenElements({ includeElementInLoop = false } = {}) {\n    let descendant = null\n    if (includeElementInLoop) {\n      descendant = findInside(this.element, '[d-state] [d-component], [d-state] [d-state], [d-component] [d-state], [d-component] [d-state]')\n    } else {\n      descendant = findInside(this.element, '[d-loop] [d-state], [d-loop] [d-component], [d-state] [d-component], [d-state] [d-state], [d-component] [d-state], [d-component] [d-state]')\n    }\n    return findInside(this.element, '[d-state], [d-component]').filter((ele) => !descendant.includes(ele))\n  }\n\n  // find the most upper children that matches selector\n  findTopLevel(selector) {\n    let descendant\n    if (selector == '[d-loop]') {\n      descendant = findInside(this.element, `[d-loop] ${selector}, [d-state] ${selector}, [d-state]${selector}, [d-component] ${selector}, [d-component]${selector}`)\n    } else {\n      descendant = findInside(this.element, `[d-loop] ${selector}, [d-loop]${selector}, [d-state] ${selector}, [d-state]${selector}, [d-component] ${selector}, [d-component]${selector}`)\n    }\n\n    let elements = findInside(this.element, selector).filter((ele) => !descendant.includes(ele))\n    isTag(this.element, selector) && elements.unshift(this.element)\n\n    return elements\n  }\n\n  // Assign d-ref to this.refs\n  // e.g:\n  //   directive d-ref: 'form' assign the current node to this.refs.form\n  //\n  //   d-ref: 'checkboxes[]' assign the current node to array this.refs.checkboxes\n  registerRefs() {\n    this.findTopLevel('[d-ref]').forEach((ele) => {\n      let name = getAttribute(ele, 'd-ref')\n\n      if (name.slice(-2) == '[]') {\n        name = name.slice(0, -2)\n        !this.refs[name] && (this.refs[name] = [])\n        this.refs[name].push(ele)\n      } else {\n        this.refs[name] = ele\n      }\n\n      !debug.keepDirectives && removeAttribute(ele, 'd-ref')\n    })\n  }\n\n  // A method meant to be overridden in sub-class to provide class specific hooks\n  classSpecificHooks() {\n    return {}\n  }\n\n  // Iterate Hooks to register hook to renderHooks and stateHooks\n  registerHooks() {\n    Object.entries(Hooks).concat(Object.entries(this.classSpecificHooks())).forEach(([hook, func]) => {\n      this.findTopLevel(`[${hook}]`).forEach((ele) => {\n        func(this, ele)\n      })\n    })\n  }\n\n  transistionOnStateChanging(prevState, state) {\n    prevState == state\n    return {}\n  }\n\n  _mergeState(state, newState) {\n    return deepMerge(state, newState)\n  }\n\n  shouldFollowRender(parent, transition) {\n    return true\n  }\n\n  setState(state = {}, transition = {}, triggerRendering = true) {\n    let prevState = this.state\n    let cloned = deepMerge({}, this.state)\n    let newState = typeof state == 'function' ?  state(cloned) : this._mergeState(cloned, state)\n\n    this.state = newState\n    setAttribute(this.element, 'd-state', JSON.stringify(newState))\n\n    this.stateHooks.forEach(obj => obj.hook(prevState))\n\n    transition = deepMerge(this.transistionOnStateChanging(prevState, newState), transition)\n    triggerRendering && this.render(transition)\n\n    return deepMerge({}, newState)\n  }\n\n  // transition: a temporary flag to info render to do something only once when state changes from particular value to another.\n  render(transition = {}) {\n    this.renderHooks.forEach(obj => obj.hook(transition))\n    this.children.forEach(child => child.shouldFollowRender(this, transition) && child.render(transition))\n  }\n\n  get root() {\n    let par = this.parent\n    while (true) {\n      if (par.parent) {\n        par = par.parent\n      } else {\n        break\n      }\n    }\n    return par\n  }\n}\n\nexport { Component }\n", "import { Component } from './component'\nimport { isNil, debug, getAttribute, setAttribute, compileToFunc, compileWithComponent, querySelectorAll } from './util'\nimport { Hooks } from './hooks'\nimport { generateEventFunc, generatePrefixFunc, generateDirectiveFunc, Prefixes } from './hook_helpers'\n\nconst Classes = {}\nconst registerComponents = (...components) => {\n  components.forEach(component => Classes[component.name] = component)\n  DRender.observer && run() // run again only if we've run it before\n}\n\n// Create a component isntance and attach it to the element with key 'd-component'\n// The argument `context` would be stored in element data 'd-component-context', and be used for directive functions\nconst createComponent = (node, { context = {}, ignoreIfClassNotFound = false } = {}) => {\n  if (node._dComponent != undefined) return node._dComponent\n\n  node._dComponentContext = context\n\n  let className = getAttribute(node, 'd-component')\n\n  // Return if the specified class is not registered to DRender yet\n  // We will back to it later while the component class is registered to DRender\n  // The component must be a top level component.\n  if (ignoreIfClassNotFound && !isNil(className) && !Classes[className]) {\n    debugger\n    return null\n  }\n\n  let _class = (Classes[className] || Component), component = new _class(node)\n  console.log(component)\n  node._dComponent = component\n\n  let children = component.findChildrenElements()\n  children.map(child => createComponent(child, { context }))\n\n  component.afterInitialized()\n\n  if (!debug.keepDirectives) {\n    getAttribute(node, 'd-state') && setAttribute(node, 'd-state', '')\n    getAttribute(node, 'd-component') && setAttribute(node, 'd-component', '')\n  }\n\n  return component\n}\n\n// Initialize components in view, and start the mutation observer to initialize new coming components\nconst run = () => {\n  if (!DRender.observer) {\n    DRender.observer = new MutationObserver((mutationsList, _observer) => {\n      for(const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n          //mutation.addedNodes.forEach(node => node.nodeType == node.ELEMENT_NODE && console.log('added Node', node))\n          mutation.addedNodes.forEach((node) => {\n            if (node.nodeType === node.ELEMENT_NODE) {\n              if (node.hasAttribute('d-component') || node.hasAttribute('d-state')) {\n                createComponent($(node)).render()\n                emitEnvent(node, 'd-component-initialized-from-mutation')\n              } else {\n                if (node.querySelectorAll('[d-component], [d-state]').length > 0) {\n                  let descendant = findInside(node, '[d-state] [d-component], [d-state] [d-state], [d-component] [d-state], [d-component] [d-state]')\n                  let top = findInside(node, '[d-state], [d-component]').filter(ele => !descendant.includes(ele))\n                  top.forEach((node) => createComponent(node).render())\n                  top.forEach((node) => emitEnvent(node, 'd-component-initialized-from-mutation'))\n                }\n              }\n            }\n          })\n        }\n      }\n    });\n    DRender.observer.observe(document, { childList: true, subtree: true })\n  }\n\n  let descendant = querySelectorAll('[d-state] [d-component], [d-state] [d-state], [d-component] [d-state], [d-component] [d-state]')\n  let top = querySelectorAll('[d-state], [d-component]').filter(ele => !descendant.includes(ele))\n  top.forEach((node) => {\n    let component = createComponent(node, { ignoreIfClassNotFound: true })\n    component && component.render()\n  })\n}\n\nconst DRender = {\n  run,\n  registerComponents,\n  Classes,\n  Component,\n  Hooks,\n  Prefixes,\n  createComponent,\n  generateEventFunc,\n  generateDirectiveFunc,\n  generatePrefixFunc,\n  debug,\n  compileToFunc,\n  compileWithComponent,\n}\n\nexport default DRender\n"],
  "mappings": "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",
  "names": ["removeAttribute", "getData", "setData", "findInside", "str", "removeAttribute", "component", "getData", "setData", "findInside", "removeAttribute", "createComponent", "descendant", "top", "node"]
}
